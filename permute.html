<!DOCTYPE html>
<html>
<head>
<title>haroldbot (permute)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" type="text/css" href="mainstyle.css" />
<script type="text/javascript" src="minisat.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="jquery.color-2.1.2.min.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript">
var $j = jQuery.noConflict();
var id = 0;
var cnf = "";
var clauses = 0;

function cnf_bfly_stage(k, mask, indices) {
  var res_indices = new Int32Array(64 * 6);
  for (var i = 0; i < 64; i++) {
    var j = i ^ (1 << k);
    res_indices.set(cnf_mux_array(mask[i & ~(1 << k)], indices.subarray(j * 6, j * 6 + 6), indices.subarray(i * 6, i * 6 + 6)), i * 6);
    if ((i & (1 << k)) != 0) {
      cnf += -mask[i] + " 0\n";
      clauses++;
    }
  }

  return res_indices;
}

function cnf_rol_stage(rot_dist, indices) {
  var res = indices;
  for (var k = 1, ki = 0; k < 64; k *= 2, ki++) {
    var rr = new Int32Array(64 * 6);
    for (var i = 0; i < 64; i++) {
      var j = (i - k + 64) & 63;
      rr.set(cnf_mux_array(rot_dist[ki], res.subarray(j * 6, j * 6 + 6), res.subarray(i * 6, i * 6 + 6)), i * 6);
    }
    res = rr;
  }

  return res;
}

function cnf_mux_array(cond, t, f) {
  var res = new Int32Array(t.length);
  for (var i = 0; i < res.length; i++)
    res[i] = cnf_mux(cond, t[i], f[i]);
  return res;
}

function cnf_mux(c, t, f) {
  var x = ++id;
  cnf += -x + " " + c + " " + f + " 0\n";
  cnf += -x + " " + -c + " " + t + " 0\n";
  cnf += x + " " + c + " " + -f + " 0\n";
  cnf += x + " " + -c + " " + -t + " 0\n";
  clauses += 4;
  return x;
}

function cnf_eq(vars, value) {
  vars.forEach(function (x) {
    var v = (value & 1) == 0 ? -x : x;
    cnf += v + " 0\n";
    clauses++;
    value >>= 1;
  });
}

function cnf_different_or_zero(v1, v2) {
  var is_nzero = ++id;
  var are_different = ++id;
  cnf += -is_nzero + " " + are_different + " 0\n";
  clauses++;
  v1.forEach(function (v, i) {
    var w = v2[i];
    cnf += is_nzero + " " + -v + " 0\n";
    cnf += is_nzero + " " + -w + " 0\n";
    clauses += 2;
  });
  var diff = [];
  v1.forEach(function (v, i) {
    var w = v2[i];
    var c = ++id;
    diff.push(c);
    cnf += -c + " " + -v + " " + -w + " 0\n";
    cnf += -c + " " + v + " " + w + " 0\n";
    clauses += 2;
  });
  cnf += -are_different + " " + diff.join(" ") + " 0\n";
  clauses++;
}

function solve(cb) {
    var solve_string = Module.cwrap('solve_string', 'string', ['string', 'int']);
    var str = "p cnf " + id + " " + clauses + "\n" + cnf;
    var res = solve_string(str, str.length);
    var parts = res.split(" ");
    var r = null;
    if (parts[0] == "SAT") {
      r = new Int8Array(id);
      for (var i = 1; i < parts.length; i++) {
        var v = parseInt(parts[i]);
        if (v > 0)
          r[v] = 1;
      }
    }
    if (cb) cb(r);
    return r;
}

function route(bitpos, sm) {
  id = 1;
  clauses = 0;
  var FALSE = 1, TRUE = -1;
  cnf = "-1 0\n";
  clauses = 1;

  var indices = new Int32Array(64 * 6);
  for (var i = 0; i < 64; i++) {
    for (var j = 0; j < 6; j++) {
      indices[i * 6 + j] = ((i >> j) & 1) == 0 ? FALSE : TRUE;
    }
  }

  var maskvars = [];
  for (var i = 0; i < 12; i++) {
    maskvars[i] = new Int32Array(64);
    for (var j = 0; j < maskvars[i].length; j++) {
      maskvars[i][j] = ++id;
      if ((sm & (1 << i)) == 0) {
        cnf += -maskvars[i][j] + " 0\n";
        clauses++;
      }
    }
  }

  var rol_dist = new Int32Array(6);
  for (var j = 0; j < rol_dist.length; j++) {
    rol_dist[j] = ++id;
    if ((sm & (1 << 12)) == 0) {
      cnf += -rol_dist[j] + " 0\n";
      clauses++;
    }
  }

  cnf_different_or_zero(maskvars[0], maskvars[11]);
  cnf_different_or_zero(maskvars[1], maskvars[10]);
  cnf_different_or_zero(maskvars[2], maskvars[9]);
  cnf_different_or_zero(maskvars[3], maskvars[8]);
  cnf_different_or_zero(maskvars[4], maskvars[7]);
  cnf_different_or_zero(maskvars[5], maskvars[6]);

  var i1 = indices;
  if ((sm & (1 << 12)) != 0) {
    i1 = cnf_rol_stage(rol_dist, i1);
  }

  var stagenum = [5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 5];
  for (var i = 0; i < maskvars.length; i++) {
    if ((sm & (1 << i)) != 0)
      i1 = cnf_bfly_stage(stagenum[i], maskvars[i], i1);
  }

  for (var i = 0; i < bitpos.length; i++) {
    if (bitpos[i] >= 0)
      cnf_eq(i1.subarray(i * 6, i * 6 + 6), bitpos[i]);
  }

  var result = solve();
  if (result) {
    var d = {};
    d.masks = [];
    d.shiftseq = [32, 16, 8, 4, 2, 1, 1, 2, 4, 8, 16, 32];
    for (var i = 0; i < 12; i++)
      d.masks[i] = result.subarray(maskvars[i][0], maskvars[i][0] + 64);
    d.rol_dist = 0;
    for (var i = 0; i < 6; i++)
      d.rol_dist += result[rol_dist[i]] << i;

    var changed = true;
    while (d.shiftseq.length > 1 && changed) {
      changed = false;
      for (var i = d.shiftseq.length - 1; i >= 0; i--) {
        if (d.masks[i].every(function (x){return x==0;})) {
          d.shiftseq.splice(i, 1);
          d.masks.splice(i, 1);
          changed = true;
        }
        else if (i > 0 && d.shiftseq[i] == d.shiftseq[i - 1]) {
          var xmask = d.masks[i].map(function (x, j) {
            return d.masks[i - 1][j] ^ x;
          });
          if (xmask.every(function (x) {return x==0;})) {
            // no exchanges, drop stages
            d.shiftseq.splice(i - 1, 2);
            d.masks.splice(i - 1, 2);
          }
          else {
            // some exchanges, xor stages
            d.shiftseq.splice(i - 1, 1);
            d.masks.splice(i - 1, 2, xmask);
          }
          changed = true;
        }
      }
    }
    if (!data.masks || (d.masks.length + (d.rol_dist == 0 ? 0 : 1)) < (data.masks.length + (data.rol_dist == 0 ? 0 : 1)))
      data = d;
    return true;
  }
  return false;
}

function performQuery(permute) {
  var parts = permute.split(" ");
  var bitpos = new Int32Array(64);
  bitpos.fill(-1);
  var bitidx = 0;
  for (var i = 0; i < parts.length && i < 64; i++) {
    if (parts[i] == "*") {
      bitidx++;
      continue;
    }
    else if (parts[i].indexOf("..") >= 0) {
      var bounds = parts[i].split("..");
      var l = parseInt(bounds[0]);
      var h = parseInt(bounds[1]);
      if (l < 0 || h < 0 || isNaN(l) || isNaN(h) || l > 63 || h > 63) {
        data.msg = "bad index";
        update();
        return;
      }
      if (l <= h) {
        for (var j = l; j <= h; j++)
          bitpos[bitidx++] = j;
      }
      else {
        for (var j = l; j >= h; j--)
          bitpos[bitidx++] = j;
      }
    }
    else {
      var val = parseInt(parts[i]);
      if (val < 0 || isNaN(val) || val > 63) {
        data.msg = "bad index";
        update();
        return;
      }
      bitpos[bitidx++] = val;
    }
  }

  data = { input: bitpos };

  var rol_dist = 0;
  for (var i = 0; i < 64; i++) {
    if (bitpos[i] >= 0) {
      rol_dist = (i - bitpos[i]) & 63;
      break;
    }
  }

  if (bitpos.every(function (p, i) { return p == -1 || p == ((i - rol_dist) & 63); })) {
    data.shiftseq = [];
    data.masks = [];
    data.rol_dist = rol_dist;
    update();
    return;
  }

  var msk_sequence = [0xFFF, 0x103F, 0x3F, 0x103E];

  function iter(i) {
    var msk = msk_sequence[i];
    if (route(bitpos, msk)) {
      update();
      if (i < msk_sequence.length)
        window.setTimeout(iter, 0, i + 1);
    }
    else if (!data.masks) {
      data.msg = "Could not route the permutation";
      update();
    }
  }

  window.setTimeout(iter, 0, 0);
}

var data = null;

function update() {
  parens = $j('#explicitparens').is(':checked');
  $j('#resultDiv').empty();
  
  if (data == null || data == undefined) {
    $j('#resultDiv').append("Query Failed");
    return;
  }

  if (data.msg) {
    $j('#resultDiv').append(data.msg);
    return;
  }

  function formatMask(bits) {
    var r = "0x";
    for (var nib = 15; nib >= 0; nib--) {
      var n = 0;
      for (var i = 0; i < 4; i++)
        n += bits[nib * 4 + i] << i;
      r += n.toString(16);
    }
    return r;
  }

  if (data.masks && (data.masks.length > 0 || data.rol_dist != 0)) {
    var code = "";
    if (data.rol_dist != 0) {
      code = "x = (x << " + data.rol_dist + ") | (x >> " + (64 - data.rol_dist) + ")\n";
    }
    for (var i = 0; i < data.masks.length; i++) {
      code += "x = bit_permute_step(x, " + formatMask(data.masks[i]) + ", " + data.shiftseq[i] + ");\n";
    }
    var cb = $j("<pre/>").text(code).addClass("bigger");
    $j('#resultDiv').append(cb);
  }
  else if (data.masks && data.masks.length == 0 && data.rol_dist == 0) {
    $j('#resultDiv').append($j("<p/>").append("No stages (identity permutation)"));
  }
}

function doquery(q) {
  if (q === undefined || q == null || q.length == 0 || q === 0)
    return;
  $j('#q').val(decodeURIComponent(q.replace(/\+/g, " ")));
  $j('#resultDiv').empty();
  $j('#resultDiv').text('Waiting for result...');
  performQuery(decodeURIComponent(q.replace(/\+/g, " ")));
}
$j(document).ready(function(){
  doquery(urlParam('q'));
});
</script>
</head>
<body>
<div id="header"><h1>haroldbot 2 (permutation mode)</h1>
</div>
<div id="querybar">
  <div id="querybox">
    <form method="get">
      <input type="text" placeholder="permutation" name="q" id="q" autofocus/>
      <input type="submit" value="compute" id="submit"/>
    </form>
  </div>
</div>
<div id="page">
  <div id="query-printback"></div>
  <div id="resultDiv"></div>
  <div id="examples">
    <h2>Examples</h2>
    <p>Simple bit-swap<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="permute.html?q=1+0+2..63"><tt>1 0 2..63</tt></a></p>
    <p>Sometimes a rotate is used<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="permute.html?q=2+1+3..63+0"><tt>2 1 3..63 0</tt></a></p>
    <p>Reverse bits<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="permute.html?q=63..0"><tt>63..0</tt></a></p>
    <p>Large permutation with don't-cares<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="permute.html?q=3+11+19+27+*+*+*+2+10+18+26+34+*+*+1+9+17+25+33+41+*+0+8+16+24+32+40+48+*+7+15+23+31+39+47+*+*+14+22+30+38+46+*+*+*+21+29+37+45"><tt>3 11 19 27 * * * 2 10 18 26 34 * * 1 9 17 25 33 41 * 0 8 16 24 32 40 48 * 7 …</tt></a></p>
  </div>
  <div>
    <h2>Notes</h2>
    <p>This is (for now) only a tool to generate permutations of a 64bit word using an optional rotation at the start and then delta swaps with power-of-two shift counts, with the large shift counts at the begin and end and the shift count of 1 in the middle. Steps with a mask of zero are omitted, in the worst case an 11-step Beneš network will be used. As special cases the result may be a butterfly network or a single delta swap or even <i>nothing</i>. No other approaches are attempted so in general the result is not optimal.</p>
    <p>The solving approach is pretty dumb, I just make a routing network with variable masks, constrain the output indices, and have MiniSAT solve for the masks.</p>
    <p>Since everything happens client-side, I don't get automatic bug reports. Please <a href="https://github.com/IJzerbaard/haroldbot/issues">open an issue</a> or contact me (eg via email or twitter @HaroldAptroot).</p>
  </div>
</div>
</body>
</html>
