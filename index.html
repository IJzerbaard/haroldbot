<!DOCTYPE html>
<html>
<head>
<title>haroldbot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" type="text/css" href="mainstyle.css" />
<script type="text/javascript" src="minisat.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="jquery.color-2.1.2.min.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="abstractinterp.js"></script>
<script type="text/javascript" src="expr.js"></script>
<script type="text/javascript" src="parser.js"></script>
<script type="text/javascript" src="bigint.js"></script>
<script type="text/javascript" src="bdd.js"></script>
<script type="text/javascript" src="bddfunction.js"></script>
<script type="text/javascript" src="sat.js"></script>
<script type="text/javascript" src="circuit.js"></script>
<script type="text/javascript" src="circuitfunction.js"></script>
<script type="text/javascript" src="prooffinder.js"></script>
<script type="text/javascript">
var $j = jQuery.noConflict();
var id = 0;

function performQuery(input) {
  id = 0;
  bdd.reset();
  circuit.reset();
  var p = parse(input);
  var expr = p[0];
  var varmap = p[1];
  var msg = p[2];

  if (p[0] == undefined) {
    data = {};
    data.msg = msg;
    update();
    return;
  }

  var abstractinterpEnv = {
    nr: []
  };
  expr.analyze(abstractinterpEnv);

  parens = true;
  $j('#query-printback').append($j("<p>Parsed as:<br/></p>").append(formatexpr(expr.removeDummy(), 0, varmap)));
  var cf = expr.removeDummy().constantFold();
  if (!cf.equals2(expr.removeDummy())) {
    $j('#query-printback').append($j("<p>After constant folding:<br/></p>").append(formatexpr(cf, 0, varmap)));
  }

  // try limited search for proof first
  data = {
    varmap: varmap
  };
  if (expr.type == 'bin' && expr.op == 20) {
    var pf = new ProofFinder(expr.op);
    var proof = null;
    pf.Search(expr.l.removeDummy(), expr.r.removeDummy(), function (proofsteps) {
      proof = proofsteps;
    }, function (exprc, backwards) {
      if (backwards) {
        //$j('#exprdebug1').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
      }
      else {
        //$j('#exprdebug0').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
      }
    }, 'synchronous', 400);
    if (proof != null) {
      data.true = {
        count: '#always',
        proof: proof
      };
      update();
      return;
    }
  }

  var bddf;
  var circuitf;
  try {
    //throw "BDD full";
    bddf = expr.toBddFunc();
  }
  catch (err) {
    if (err == "BDD full" || err == "multiplication seems hard")
      circuitf = expr.toCircuitFunc();
    else {
      //throw err;
      data.msg = err;
      return;
    }
  }

  if (expr.type == 'bin' && (expr.op >= 20 && expr.op <= 28 || expr.op >= 40 && expr.op <= 48)) {
    // comparison
    (bddf||circuitf).AnalyzeTruth(data, expr.removeDummy(), varmap, function () {
      update();
    }, function (exprc, backwards) {
      if (backwards) {
        //$j('#exprdebug1').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
      }
      else {
        //$j('#exprdebug0').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
      }
    });
    update();
  }
  else {
    if (bddf) {
      data.simp = bddf.Identify(varmap);
      if (data.simp == undefined) {
        data.msg = "bdd structural pattern matcher didn't work (it's still quite broken)"
      }
      else {
        var pf = new ProofFinder(20);
        pf.Search(expr.removeDummy(), data.simp, function (flatproof) {
          data.proof = flatproof;
          update();
        }, function (exprc, backwards) {
          if (backwards) {
            //$j('#exprdebug1').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
          }
          else {
            //$j('#exprdebug0').append($j('<div/>').append(formatexpr(exprc, 99999, varmap)));
          }
        });
      }
      
      bddf.AnalyzeProperties(data, varmap, null);
      update();
    }
    else {
      data.msg = "SAT fallback can only handle expressions that result in true or false";
      update();
    }
  }
}

function formatVariableAssignment(assignment, varmap_in, ext_examples) {
  var varmap = varmap_in.slice();
  if (ext_examples) {
    varmap.push('lhs');
    varmap.push('rhs');
  }
  var table = $j('<table class="varassignment"></table>');
  for (var i = 0; i < varmap.length; i++) {
    var row = $j('<tr></tr>');
    row.append($j('<td>' + varmap[i] + '</td>'));
    row.append("=");
    row.append($j('<td>' + formatConstant(assignment[i]) + '</td>'));
    table.append(row);
  }
  return table;
}

function formatVariableAssignments(assignment, varmap_in, ext_examples) {
  var varmap = varmap_in.slice();
  if (ext_examples) {
    varmap.push('lhs');
    varmap.push('rhs');
  }
  var wrapper = $j('<div/>');
  var table = $j('<table class="varassignment"></table>');
  var headers = $j('<tr/>');
  if (varmap.length > 1) {
    for (var i = 0; i < varmap.length; i++)
      headers.append($j('<th>' + varmap[i] + '</th>'));
    table.append(headers);
  }
  var first = 0;
  var last = 0;
  while (last < 4) {
    var asign = assignment(last++);
    if (asign == undefined)
      break;
    var row = $j('<tr/>');
    for (var i = 0; i < varmap.length; i++) {
      var col = $j('<td>' + formatConstant(asign[i]) + '</td>');
      row.append(col);
    }
    table.append(row);
  }

  var morebutton = null;
  if (assignment(last) != undefined) {
    morebutton = $j('<button/>');
    morebutton.text('...');
    morebutton.css('border-radius', '5px');
    morebutton.click(function () {
      for (var end = last + 4; last < end; last++) {
        var asign = assignment(last);
        if (asign == undefined)
          break;
        var row = $j('<tr/>');
        for (var i = 0; i < varmap.length; i++) {
          row.append($j('<td>' + formatConstant(asign[i]) + '</td>'));
        }
        table.append(row);
      }
      table.animate({scrollTop: table.prop('scrollHeight') - table.height()}, 100);
    });
    morebutton.bind('contextmenu', function() {
      if (last == 0)
        return false;
      var end = last - 4;
      while (last > 1 && last > end) {
        last--;
        $j('tr:last', table).remove();
      }
      return false;
    });
  }
  wrapper.append(table);
  if (morebutton != null)
  wrapper.append(morebutton);
  return wrapper;
}

var parens = false;

function formatexpr(expr, ix, varmap) {
  varmap[0];
  var res = $j("<span />").addClass("e" + ix + "_" + expr.id);
  res.css("border-radius", "5px");
  if (expr[0] == "#") {
    res.append(formatexpr(expr[2], ix, varmap));
    return res;
  }
  if (expr.type == 'var') {
    if (expr.index >= 0)
      res.append(varmap[expr.index]);
    else
      res.append(['x', 'y', 'z', 'w', 'p', 'q', 'r', 's', 't', 'u', 'v'][~expr.index]);
    return res;
  }
  if (expr.type == 'const') {
    res.append(formatConstant(expr.value));
    return res;
  }
  if (expr.type == 'un') {
    var inner = formatexpr(expr.value, ix, varmap);

    if (unops[expr.op].startsWith('$')) {
      return res.append(unops[expr.op].substr(1) + '(').append(inner).append(')');
    }

    res.append(unops[expr.op]);
    if ((expr.value.type == 'bin' && expr.value.op < 55) || expr.value.type == 'ter') {
      res.append('(');
      res.append(inner);
      res.append(')');
    }
    else
      res.append(inner);
    return res;
  }
  if (expr.type == 'bin') {
    var l = formatexpr(expr.l, ix, varmap);
    var r = formatexpr(expr.r, ix, varmap);

    if (ops[expr.op].startsWith('$')) {
      return res.append(ops[expr.op].substr(1) + '(').append(l).append(', ').append(r).append(')');
    }

    if (expr.l.type == 'bin' && (parens || precedence(expr.op) > precedence(expr.l.op)) || expr.l.type == 'ter') {
      res.append('(');
      res.append(l);
      res.append(')');
    }
    else
      res.append(l);
    
    res.append(" " + escapeHtml(ops[expr.op]) + " ");
    
    if (expr.r.type == 'bin' && (parens || precedence(expr.op) > precedence(expr.r.op)) || expr.r.type == 'ter') {
      res.append('(');
      res.append(r);
      res.append(')');
    }
    else
      res.append(r);
      
    return res;
  }
  if (expr.type == 'ter') {
    var cond = formatexpr(expr.cond, ix, varmap);
    var t = formatexpr(expr.t, ix, varmap);
    var f = formatexpr(expr.f, ix, varmap);

    return res.append(cond).append(" ? ").append(t).append(" : ").append(f);
  }
  debugger;
}
function parseproofstep(proofstep, ix, varmap) {
  varmap[0];
  var container = $j('<div/>').addClass("proofj");
  container.attr("id", "proofj" + (ix + 1));
  var explanation = $j('<div/>').html(proofstep[0]).contents();
  if (proofstep[2]) {
    var ex = escape(proofstep[2].print(varmap));
    explanation.filter('.replace').attr('href', 'index.html?q=' + ex);
  }
  container.append(explanation);
  if (proofstep[1]) {
    container.append(", ");
    var pattern = formatexpr(["#",-1,proofstep[1].l], ix, varmap);
    var patternr = formatexpr(["#",-1,proofstep[1].r], ix + 2, varmap);
    if (proofstep[1].l.type == 'bin' && precedence(proofstep[1].l.op) <= precedence(proofstep[1].op))
      pattern = $j("<span />").append("(").append(pattern).append(")");
    if (proofstep[1].r.type == 'bin' && precedence(proofstep[1].r.op) <= precedence(proofstep[1].op))
      patternr = $j("<span />").append("(").append(patternr).append(")");
    var patternholder = $j('<span/>');
    patternholder.css('font-family', 'Consolas,monospace');
    patternholder.append(pattern).append(" " + ops[proofstep[1].op] + " ").append(patternr);
    container.append(patternholder);
    pattern.find('span').each(function(index, elem) {
      var cl = "." + $j(elem).attr('class');
      var color = randomColor();
      $j(elem).hover(function() {
        $j("#proofj" + ix + ", #proofj" + (ix + 1)).find(cl).stop().animate({backgroundColor:color}, 300);
      }, function() {
        $j(cl).find('span').andSelf().stop().css("background-color", "");
      });
    });
    patternr.find('span').each(function(index, elem) {
      var cl = "." + $j(elem).attr('class');
      var color = randomColor();
      $j(elem).hover(function() {
        $j("#proofj" + (ix + 1) + ", #proofj" + (ix + 2)).find(cl).stop().animate({backgroundColor:color}, 300);
      }, function () {
        $j(cl).find('span').andSelf().stop().css("background-color", "");
      });
    });
  }
  return container;
}
function formatproof(parent, proofarray, varmap) {
  varmap[0];
  var assocsteps = $j('#explicitparens').is(':checked');
  var proofcontainer = $j('<p/>');
  proofcontainer.append($j('<p>proof:</p>'));
  var havesteps = false;
  for (var i = 0; i < proofarray.length; i++) {
    if (i % 2 == 0) {
      var container = $j('<div/>');
      container.attr("id", "proofj" + i);
      var exprholder = $j('<b/>');
      exprholder.css('font-family', 'Consolas,monospace');
      container.append(exprholder.append(formatexpr(proofarray[i], i, varmap)));
      proofcontainer.append(container);
    }
    else {
      if (!assocsteps && proofarray[i][0] && proofarray[i][0].indexOf('associativity') == 0)
        i++;
      else {
        proofcontainer.append(parseproofstep(proofarray[i], i - 1, varmap));
        havesteps = true;
      }
    }
  }
  $j('#displayoptions').show();
  if (havesteps)
    parent.append(proofcontainer);
}

var data = null;

function update() {
  parens = $j('#explicitparens').is(':checked');
  $j('#resultDiv').empty();
  
  if (data == null || data == undefined) {
    $j('#resultDiv').append("Query Failed");
    return;
  }
  var varmap = data.varmap;

  if (data.msg) {
    $j('#resultDiv').append('<p>' + data.msg + '</p>');
  }

  function makeMainInfoBox(stuff, name) {
    if (!stuff)
      return;

    var container = $j('<fieldset/>');
    container.append($j('<legend>' + name + '</legend>'));
    if (stuff.count.startsWith('#')) {
      container.append('<p>' + stuff.count.substring(1) + '</p>');
      if (stuff.examples)
        container.append($j('<p>for example:</p>').append(formatVariableAssignments(stuff.examples, varmap, stuff.ext_examples)));
      if (stuff.proof)
        formatproof(container, stuff.proof, varmap);
    }
    else if (stuff.count == '1') {
      if (stuff.examples) {
        var varassign = formatVariableAssignment(stuff.examples(0), varmap, stuff.ext_examples);
        container.append($j('<p>once, namely:</p>').append(varassign));
      }
      else
        container.append('<p>once</p>');
    }
    else if (stuff.count) {
      container.append('<p>in ' + stuff.count + ' cases</p>');
      if (stuff.examples)
        container.append($j('<p>for example:</p>').append(formatVariableAssignments(stuff.examples, varmap, stuff.ext_examples)));
    }
    else {
      debugger;
      alert('should be unreachable');
    }
    
    $j('#resultDiv').append(container);
  }

  makeMainInfoBox(data.diverror, 'divide error');
  makeMainInfoBox(data.true, 'true');
  makeMainInfoBox(data.false, 'false');

  if (data.simp) {
    $j('#displayoptions').show();
    var simpcont = $j('<fieldset/>');
    simpcont.append($j('<legend>simplified</legend>'));
    simpcont.append($j('<b></b>').append(formatexpr(data.simp, 1000000, data.varmap)));
    if (data.proof) {
      if (data.proof[1][0] != 'structurally equal')
        formatproof(simpcont, data.proof, data.varmap);
    }
    
    $j('#resultDiv').append(simpcont);
  }
  if (data.properties) {
    var prop = data.properties;
    var propscont = $j('<fieldset/>');
    propscont.append($j('<legend>properties</legend>'));
    var haveAny = false;
    if (prop.hasOwnProperty('nibmask')) {
      propscont.append($j('<div>nibble mask: ' + prop.nibmask + '</div>'));
      haveAny = true;
    }
    if (prop.hasOwnProperty('bitmask')) {
      propscont.append($j('<div>bit mask: ' + prop.bitmask + '</div>'));
      haveAny = true;
    }

    function makeCollapsible(base, text, value, count, examples, varmap) {
      var extra = null;
      if (count == "1")
        extra = $j('<div/>').append('once:').append(formatVariableAssignment(examples(0), varmap, false));
      else
        extra = $j('<div/>').append(count + ' cases').append(formatVariableAssignments(examples, varmap, false));
      extra.css('overflow', 'hidden');
      var showbutton = $j('<a/>', {
        text: '▸',
        style: 'color:#000',
        class: 'bigger',
        click: function() { extra.slideToggle(); $j(this).text($j(this).text() == '▸' ? '▾' : '▸'); }
      });
      base.append($j('<div/>').append(text + formatConstant(value) + '&nbsp;').append(showbutton));
      base.append(extra);
      extra.hide();
    }

    if (prop.hasOwnProperty('lowestUnsigned')) {
      makeCollapsible(propscont, 'lowest unsigned: ', prop.lowestUnsigned.value, prop.lowestUnsigned.count, prop.lowestUnsigned.examples, data.varmap);
      haveAny = true;
    }
    if (prop.hasOwnProperty('highestUnsigned')) {
      makeCollapsible(propscont, 'highest unsigned: ', prop.highestUnsigned.value, prop.highestUnsigned.count, prop.highestUnsigned.examples, data.varmap);
      haveAny = true;
    }

    // only make this box if there's anything in it
    if (haveAny)
      $j('#resultDiv').append(propscont);
  }
}

function doquery(f) {
  if (f === undefined || f == null || f.length == 0)
    return;
  $j('#displayoptions').hide();
  $j('#q').val(decodeURIComponent(f.replace(/\+/g, " ")));
  $j('#resultDiv').empty();
  $j('#resultDiv').text('Waiting for result...');
  performQuery(decodeURIComponent(f.replace(/\+/g, " ")));
}
$j(document).ready(function(){
  if (ls.get('explicitparens'))
    $j('#explicitparens').prop('checked', ls.get('explicitparens') == 2);
  $j(':checkbox').change(function() {
    ls.set('explicitparens', $j('#explicitparens').is(':checked') ? 2 : 1);
    update();
  });
  doquery(urlParam('q'));
});
</script>
</head>
<body>
<div id="header"><h1>haroldbot 2</h1>
(due to infrastructure changes this is an entirely new version with new bugs)<br/><br/>
</div>
<div id="querybar">
  <div id="querybox">
    <form method="get">
      <input type="text" placeholder="query" name="q" id="q" autofocus/>
      <input type="submit" value="ask" id="submit"/>
    </form>
  </div>
</div>
<div id="page">
  <div id="displayoptions" style="display:none">
    <label><input type="checkbox" id="explicitparens" />show more parentheses</label>
  </div>
  <div id="query-printback"></div>
  <div id="resultDiv"></div>
  <div id="examples">
    <h2>Examples</h2>
    <p>Just do some math<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="index.html?q=1000%20%2B%2015%20%26%20-16"><tt>1000 + 15 &amp; -16</tt></a></p>
    <p>Find out whether two expressions are equivalent<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="index.html?q=let+x+%3D+a+%2B+b+in+%28x+<+a%29+%3D%3D+%28x+<+max%28a%2C+b%29%29"><tt>let x = a + b in (x &lt; a) == (x &lt; max(a, b))</tt></a></p></p>
    <p><i>Prove</i> that two expressions are equivalent<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="index.html?q=a+%5E+%28%28a+%5E+b%29+%26+mask%29+%3D%3D+%28a+%26+~mask%29+%7C+%28b+%26+mask%29"><tt>a ^ ((a ^ b) &amp; mask) == (a &amp; ~mask) | (b &amp; mask)</tt></a></p></p>
    <p>Find when two expressions are equal and when they are not<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;<a href="index.html?q=x+%3D%3D+-x"><tt>x == -x</tt></a></p>
  </div>
  <div>
    <h2>Notes</h2>
    <p>== binds less strongly than bitwise operators.</p>
    <p>Finding proofs can be slow and often nothing is found at all.</p>
    <p>The BDD structural matcher has not been fully ported yet.</p>
    <p>SAT fallback now exists, using MiniSat compiled with Emscripten. This is brand new so expect bugs (not due to MiniSat, but for example I don't entirely trust my circuit builder and circuit-to-SAT converter). haroldbot should now give up early on (some) multiplications that would create a gigantic BDD.</p>
    <p>In general, there <i>are</i> many bugs.</p>
    <p>Since everything happens client-side now, I don't get automatic bug reports. Please <a href="https://github.com/IJzerbaard/haroldbot/issues">open an issue</a> or contact me (if you know how).</p>
  </div>
  <div>
    <h2>List of available functions</h2>
    <ul>
      <li><tt>min = min_u, min_s</tt></li>
      <li><tt>max = max_u, max_s</tt></li>
      <li><tt>popcnt</tt></li>
      <li><tt>nlz</tt> number of leading zeroes</li>
      <li><tt>ntz</tt> number of trailing zeroes</li>
      <li><tt>reverse</tt> bit-reversal</li>
      <li><tt>hmul = hmul_u, hmul_s</tt> high half of product</li>
    </ul>
  </div>
  <div id="exprdebug">
    <div id="exprdebug0"></div>
    <div id="exprdebug1"></div>
  </div>
</div>
<div id="footer">
  haroldbot &copy; Harold Aptroot 2014-2017 <a rel="license"  href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>
</div>
</body>
</html>
